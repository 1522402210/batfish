package org.batfish.bddreachability;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.batfish.common.util.CommonUtil.toImmutableMap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Suppliers;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.sf.javabdd.BDD;
import org.batfish.common.BatfishException;
import org.batfish.datamodel.Flow;
import org.batfish.datamodel.Flow.Builder;
import org.batfish.symbolic.bdd.BDDOps;
import org.batfish.symbolic.bdd.BDDPacket;
import org.batfish.z3.expr.StateExpr;
import org.batfish.z3.state.Accept;
import org.batfish.z3.state.Drop;
import org.batfish.z3.state.NeighborUnreachable;
import org.batfish.z3.state.NumberedQuery;
import org.batfish.z3.state.OriginateInterfaceLink;
import org.batfish.z3.state.OriginateVrf;
import org.batfish.z3.state.PostInVrf;
import org.batfish.z3.state.PreInInterface;
import org.batfish.z3.state.visitors.DefaultTransitionGenerator;

/**
 * A new reachability analysis engine using BDDs. The analysis maintains a graph that describes how
 * packets flow through the network and through logical phases of a router. The graph is similar to
 * the one generated by {@link DefaultTransitionGenerator} for reachability analysis using NOD. In
 * particular, the graph nodes are {@link StateExpr StateExprs} and the edges are mostly the same as
 * the NOD program rules/transitions. {@link BDD BDDs} label the nodes and edges of the graph. A
 * node label represent the set of packets that can reach that node, and an edge label represents
 * the set of packets that can traverse the edge.
 *
 * <p>The two main departures from the NOD program are: 1) ACLs are encoded as a single BDD that
 * labels an edge (rather than a series of states/transitions in NOD programs). 2) Source NAT is
 * handled differently -- we don't maintain separate original and current source IP variables.
 * Instead, we keep track of where/how the packet is transformed as it flows through the network,
 * and reconstruct it after the fact. This requires some work that can't be expressed in BDDs.
 */
public class BDDReachabilityAnalysis {
  /*
   * Stores the essential information about a logical NAT root -- where the NAT occurred, and
   * what the original root was.
   */
  private static class NatRootPosition {
    final StateExpr _natPosition;
    final StateExpr _originalRoot;
    final List<BDDSourceNat> _sourceNats;

    NatRootPosition(StateExpr natPosition, StateExpr originalRoot, List<BDDSourceNat> sourceNats) {
      _natPosition = natPosition;
      _originalRoot = originalRoot;
      _sourceNats = sourceNats;
    }
  }

  private final BDDPacket _bddPacket;

  // preState --> postState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _edges;

  // postState --> preState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _reverseEdges;

  private final Map<StateExpr, BDD> _graphRoots;

  // logical root --> (position,original root)
  private final Map<StateExpr, NatRootPosition> _natRootPositions;

  // natting postState --> root --> logical root
  private final Map<StateExpr, Map<StateExpr, StateExpr>> _natRoots;
  private int _natRootCounter = 0;

  // state --> source state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _reachableStates;

  // state --> final state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _reverseReachableStates;

  // root state --> leaf state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _rootToLeafBDDs;

  // for NAT
  private final BDD _srcIpVars;

  private Set<StateExpr> _leafStates;

  BDDReachabilityAnalysis(
      Map<StateExpr, BDD> graphRoots, Map<StateExpr, Map<StateExpr, Edge>> transitions) {
    _bddPacket = new BDDPacket();
    _edges = computeEdges(graphRoots, transitions);
    _reverseEdges = computeReverseEdges(_edges);
    _graphRoots = ImmutableMap.copyOf(graphRoots);
    _natRootPositions = new HashMap<>();
    _natRoots = new HashMap<>();
    _reachableStates = Suppliers.memoize(this::computeReachableStates);
    _reverseReachableStates = Suppliers.memoize(this::computeReverseReachableStates);
    _rootToLeafBDDs = Suppliers.memoize(this::computeRootToLeafBDDs);
    _leafStates = computeTerminalStates();
    _srcIpVars = new BDDOps(BDDPacket.factory).and(_bddPacket.getSrcIp().getBitvec());
  }

  private static Map<StateExpr, Map<StateExpr, Edge>> computeEdges(
      Map<StateExpr, BDD> graphRoots, Map<StateExpr, Map<StateExpr, Edge>> transitions) {
    Map<StateExpr, Map<StateExpr, Edge>> edges = new HashMap<>();
    // add root transitions
    graphRoots.forEach(
        (root, predicate) -> {
          if (root instanceof OriginateVrf) {
            OriginateVrf originateVrf = (OriginateVrf) root;
            PostInVrf postInVrf = new PostInVrf(originateVrf.getHostname(), originateVrf.getVrf());
            Edge edge = new Edge(root, postInVrf, predicate);
            edges.put(originateVrf, ImmutableMap.of(postInVrf, edge));
          } else if (root instanceof OriginateInterfaceLink) {
            OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) root;
            PreInInterface preInInterface =
                new PreInInterface(
                    originateInterfaceLink.getHostname(), originateInterfaceLink.getIface());
            Edge edge = new Edge(root, preInInterface, predicate);
            edges.put(originateInterfaceLink, ImmutableMap.of(preInInterface, edge));
          } else {
            throw new BatfishException("unexpected graph root: " + root);
          }
        });
    // add all other transitions
    transitions.forEach(edges::put);
    return ImmutableMap.copyOf(edges);
  }

  private static Map<StateExpr, Map<StateExpr, Edge>> computeReverseEdges(
      Map<StateExpr, Map<StateExpr, Edge>> edges) {
    Map<StateExpr, Map<StateExpr, Edge>> reverseEdges = new HashMap<>();
    edges.forEach(
        (preState, preStateOutEdges) ->
            preStateOutEdges.forEach(
                (postState, edge) ->
                    reverseEdges
                        .computeIfAbsent(postState, k -> new HashMap<>())
                        .put(preState, edge)));
    // freeze
    return toImmutableMap(
        reverseEdges, Entry::getKey, entry -> ImmutableMap.copyOf(entry.getValue()));
  }

  Map<StateExpr, Map<StateExpr, BDD>> getStatesReachableFromRoot(StateExpr root) {
    return _reachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> entry.getValue().containsKey(root))
        .collect(ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue));
  }

  /* backward-propagate nat roots to a fixed point */
  private void backwardPropagateNatRoots(Map<StateExpr, Map<StateExpr, BDD>> rootToLeafBDDs) {
    Set<StateExpr> natRootsWorkList = _natRootPositions.keySet();
    Map<StateExpr, Map<StateExpr, BDD>> reachableStates = _reachableStates.get();
    while (!natRootsWorkList.isEmpty()) {
      Set<StateExpr> newWorkList = new HashSet<>();
      for (StateExpr natRoot : natRootsWorkList) {
        NatRootPosition natRootPosition = _natRootPositions.get(natRoot);
        StateExpr originalRoot = natRootPosition._originalRoot;
        List<BDDSourceNat> sourceNats = natRootPosition._sourceNats;
        BDD reachNatBDD = reachableStates.get(natRootPosition._natPosition).get(originalRoot);
        Map<StateExpr, BDD> natRootLeafBDDs = rootToLeafBDDs.get(natRoot);

        if (natRootLeafBDDs == null) {
          /*
          Map<StateExpr, Map<StateExpr, BDD>> statesReachableFromRoot =
              getStatesReachableFromRoot(natRoot);
          */
          break;
        }
        checkNotNull(natRootLeafBDDs, "natRoot %s missing rootToLeafBDDs entry", natRoot);

        natRootLeafBDDs.forEach(
            (leaf, bdd) -> {
              BDD bddExistSrcIp = bdd.exist(_srcIpVars);
              BDD preNatBDD = bdd.getFactory().zero();
              for (BDDSourceNat sourceNat : sourceNats) {
                if (!bdd.and(sourceNat._updateSrcIp).isZero()) {
                  // this could be the NAT rule that was applied
                  preNatBDD =
                      preNatBDD.or(reachNatBDD.and(sourceNat._condition).and(bddExistSrcIp));
                }
              }
              assert !preNatBDD.isZero();
              rootToLeafBDDs
                  .computeIfAbsent(originalRoot, k -> new HashMap<>())
                  .merge(leaf, preNatBDD, BDD::or);
              if (_natRootPositions.containsKey(originalRoot)) {
                // original root is also a nat root; keep back-propagating
                newWorkList.add(originalRoot);
              }
            });
      }
      natRootsWorkList = newWorkList;
    }
  }

  /*
   * node --> root --> set of headers that can reach node from root.
   */
  private Map<StateExpr, Map<StateExpr, BDD>> computeReachableStates() {
    Map<StateExpr, Map<StateExpr, BDD>> reachableStates = new HashMap<>();
    Multimap<StateExpr, StateExpr> dirty = HashMultimap.create();
    for (StateExpr root : _graphRoots.keySet()) {
      reachableStates.put(root, ImmutableMap.of(root, _graphRoots.get(root)));
      dirty.put(root, root);
    }

    List<Long> roundTimes = new LinkedList<>();
    List<Integer> roundDirties = new LinkedList<>();

    while (!dirty.isEmpty()) {
      Multimap<StateExpr, StateExpr> newDirty = HashMultimap.create();
      long time = System.currentTimeMillis();

      dirty.forEach(
          (preState, root) -> {
            Map<StateExpr, Edge> preStateOutEdges = _edges.get(preState);
            if (preStateOutEdges == null) {
              // preState has no out-edges
              return;
            }

            BDD preStateBDD = reachableStates.get(preState).get(root);
            preStateOutEdges.forEach(
                (postState, edge) -> {
                  BDD result = preStateBDD.and(edge.getConstraint());
                  if (result.isZero()) {
                    return;
                  }

                  // apply source nat
                  List<BDDSourceNat> sourceNats = edge.getSourceNats();
                  boolean natted = false;
                  if (sourceNats != null) {
                    BDD orig = result;
                    result = BDDPacket.factory.zero();
                    BDD reachLine = BDDPacket.factory.one();
                    for (BDDSourceNat sourceNat : Lists.reverse(sourceNats)) {
                      BDD matchLine = reachLine.and(sourceNat._condition);
                      result =
                          result.or(
                              orig.and(matchLine).exist(_srcIpVars).and(sourceNat._updateSrcIp));
                      reachLine = reachLine.and(sourceNat._condition.not());
                    }
                    result = result.or(orig.and(reachLine));
                    natted = !result.equals(orig);
                  }

                  /*
                   * We want to remember the original source IP, but NAT is destructive. So we
                   * introduce a new "root" state and map it to a new NatRootPosition, which
                   * has the information needed to recover the original source IP and original
                   * root.
                   */
                  StateExpr logicalRoot;
                  if (natted) {
                    logicalRoot =
                        _natRoots
                            .computeIfAbsent(postState, k -> new HashMap<>())
                            .computeIfAbsent(root, k -> new NumberedQuery(this._natRootCounter++));
                    _natRootPositions.computeIfAbsent(
                        logicalRoot, k -> new NatRootPosition(preState, root, sourceNats));
                  } else {
                    logicalRoot = root;
                  }

                  // update postState BDD reachable from root
                  Map<StateExpr, BDD> reachPostState =
                      reachableStates.computeIfAbsent(postState, k -> new HashMap<>());
                  BDD oldReach = reachPostState.get(logicalRoot);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);

                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reachPostState.put(logicalRoot, newReach);
                    newDirty.put(postState, logicalRoot);
                  }
                });
          });

      dirty = newDirty;

      time = System.currentTimeMillis() - time;
      roundTimes.add(time);
      roundDirties.add(dirty.size());
    }

    return toImmutableMap(
        reachableStates,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  /*
   * node --> final --> set of headers that can reach final from node.
   */
  private Map<StateExpr, Map<StateExpr, BDD>> computeReverseReachableStates() {
    Map<StateExpr, Map<StateExpr, BDD>> reverseReachableStates = new HashMap<>();
    Multimap<StateExpr, StateExpr> dirty = HashMultimap.create();
    List<StateExpr> leaves =
        ImmutableList.of(Accept.INSTANCE, Drop.INSTANCE, NeighborUnreachable.INSTANCE);
    for (StateExpr leaf : leaves) {
      reverseReachableStates.put(leaf, ImmutableMap.of(leaf, BDDPacket.factory.one()));
      dirty.put(leaf, leaf);
    }

    List<Long> roundTimes = new LinkedList<>();
    List<Integer> roundDirties = new LinkedList<>();

    while (!dirty.isEmpty()) {
      Multimap<StateExpr, StateExpr> newDirty = HashMultimap.create();
      long time = System.currentTimeMillis();

      dirty.forEach(
          (postState, leaf) -> {
            Map<StateExpr, Edge> postStateInEdges = _reverseEdges.get(postState);
            if (postStateInEdges == null) {
              // preState has no in-edges
              return;
            }

            BDD postStateBDD = reverseReachableStates.get(postState).get(leaf);
            postStateInEdges.forEach(
                (preState, edge) -> {
                  BDD result = postStateBDD.and(edge.getConstraint());
                  if (result.isZero()) {
                    return;
                  }

                  // apply source nat backward
                  List<BDDSourceNat> sourceNats = edge.getSourceNats();
                  if (sourceNats != null) {
                    BDD orig = result;
                    BDD origExistSrcIp = orig.exist(_srcIpVars);
                    // non-natted case: srcIp unchanged, none of the lines match
                    result =
                        sourceNats
                            .stream()
                            .map(srcNat -> srcNat._condition.not())
                            .reduce(orig, BDD::and);
                    // natted cases
                    for (BDDSourceNat sourceNat : sourceNats) {
                      if (!orig.and(sourceNat._updateSrcIp).isZero()) {
                        // this could be the NAT rule that was applied
                        result = result.or(origExistSrcIp.and(sourceNat._condition));
                      }
                    }
                    assert !result.isZero();
                  }

                  // update preState BDD reverse-reachable from leaf
                  Map<StateExpr, BDD> reverseReachPreState =
                      reverseReachableStates.computeIfAbsent(preState, k -> new HashMap<>());
                  BDD oldReach = reverseReachPreState.get(leaf);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);

                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reverseReachPreState.put(leaf, newReach);
                    newDirty.put(preState, leaf);
                  }
                });
          });

      dirty = newDirty;

      Multimap<StateExpr, StateExpr> finalDirty = dirty;
      List<StateExpr> violations =
          _graphRoots
              .keySet()
              .stream()
              .filter(dirty::containsKey)
              .filter(
                  root -> {
                    BDD acceptBDD = reverseReachableStates.get(root).get(Accept.INSTANCE);
                    BDD dropBDD = reverseReachableStates.get(root).get(Drop.INSTANCE);
                    BDD neighborUnreachableBDD =
                        reverseReachableStates.get(root).get(NeighborUnreachable.INSTANCE);
                    boolean canReachAccept = acceptBDD != null;
                    boolean canReachDrop = dropBDD != null;
                    boolean canReachNeighborUnreachable = neighborUnreachableBDD != null;
                    Collection<StateExpr> reachableLeaves = finalDirty.get(root);
                    if (reachableLeaves.contains(Accept.INSTANCE)
                        || reachableLeaves.contains(Drop.INSTANCE)) {
                      if (canReachAccept && canReachDrop && !acceptBDD.and(dropBDD).isZero()) {
                        return true;
                      }
                    }
                    if (reachableLeaves.contains(Accept.INSTANCE)
                        || reachableLeaves.contains(NeighborUnreachable.INSTANCE)) {
                      if (canReachAccept
                          && canReachNeighborUnreachable
                          && !acceptBDD.and(neighborUnreachableBDD).isZero()) {
                        return true;
                      }
                    }
                    if (reachableLeaves.contains(NeighborUnreachable.INSTANCE)
                        || reachableLeaves.contains(Drop.INSTANCE)) {
                      if (canReachNeighborUnreachable
                          && canReachDrop
                          && !neighborUnreachableBDD.and(dropBDD).isZero()) {
                        return true;
                      }
                    }
                    return false;
                  })
              .collect(Collectors.toList());

      time = System.currentTimeMillis() - time;
      roundTimes.add(time);
      roundDirties.add(dirty.size());

      if (violations.size() > 1) {
        break;
      }
    }

    return toImmutableMap(
        reverseReachableStates,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Map<StateExpr, Map<StateExpr, BDD>> computeRootToLeafBDDs() {
    // root --> leaf --> BDD
    Map<StateExpr, Map<StateExpr, BDD>> rootToLeafBDDs = new HashMap<>();
    _reachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> _leafStates.contains(entry.getKey()))
        .forEach(
            entry -> {
              StateExpr leafState = entry.getKey();
              entry
                  .getValue()
                  .forEach(
                      (root, bdd) -> {
                        rootToLeafBDDs
                            .computeIfAbsent(root, k -> new HashMap<>())
                            .put(leafState, bdd);
                      });
            });

    backwardPropagateNatRoots(rootToLeafBDDs);

    return toImmutableMap(
        rootToLeafBDDs,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Set<StateExpr> computeTerminalStates() {
    Set<StateExpr> preStates = _edges.keySet();
    Set<StateExpr> postStates =
        _edges.values().stream().flatMap(m -> m.keySet().stream()).collect(Collectors.toSet());
    return ImmutableSet.copyOf(Sets.difference(postStates, preStates));
  }

  /**
   * Return a list of {@link MultipathInconsistency multipath consistency violations} detected in
   * the network.
   */
  @VisibleForTesting
  List<MultipathInconsistency> computeMultipathInconsistencies_forward() {
    return _rootToLeafBDDs
        .get()
        .entrySet()
        .stream()
        .flatMap(
            entry -> {
              StateExpr root = entry.getKey();
              Map<StateExpr, BDD> leafBDDs = entry.getValue();
              return _leafStates
                  .stream()
                  .filter(leafBDDs::containsKey)
                  .flatMap(
                      leaf1 -> {
                        BDD leaf1BDD = leafBDDs.get(leaf1);
                        return _leafStates
                            .stream()
                            .filter(leaf2 -> leaf1 != leaf2)
                            .filter(leafBDDs::containsKey)
                            // avoid duplicate violations
                            .filter(leaf2 -> leaf1.toString().compareTo(leaf2.toString()) < 1)
                            .flatMap(
                                leaf2 -> {
                                  BDD leaf2BDD = leafBDDs.get(leaf2);
                                  BDD intersection = leaf1BDD.and(leaf2BDD);
                                  return intersection.isZero()
                                      ? Stream.empty()
                                      : Stream.of(
                                          new MultipathInconsistency(
                                              root, ImmutableSet.of(leaf1, leaf2), intersection));
                                });
                      });
            })
        .collect(ImmutableList.toImmutableList());
  }

  /**
   * Return a list of {@link MultipathInconsistency multipath consistency violations} detected in
   * the network.
   */
  @VisibleForTesting
  List<MultipathInconsistency> computeMultipathInconsistencies() {
    return _reverseReachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> _graphRoots.containsKey(entry.getKey()))
        .flatMap(
            entry -> {
              StateExpr root = entry.getKey();
              Map<StateExpr, BDD> leafBDDs = entry.getValue();
              return _leafStates
                  .stream()
                  .filter(leafBDDs::containsKey)
                  .flatMap(
                      leaf1 -> {
                        BDD leaf1BDD = leafBDDs.get(leaf1);
                        return _leafStates
                            .stream()
                            .filter(leaf2 -> leaf1 != leaf2)
                            .filter(leafBDDs::containsKey)
                            // avoid duplicate violations
                            .filter(leaf2 -> leaf1.toString().compareTo(leaf2.toString()) < 1)
                            .flatMap(
                                leaf2 -> {
                                  BDD leaf2BDD = leafBDDs.get(leaf2);
                                  BDD intersection = leaf1BDD.and(leaf2BDD);
                                  return intersection.isZero()
                                      ? Stream.empty()
                                      : Stream.of(
                                          new MultipathInconsistency(
                                              root, ImmutableSet.of(leaf1, leaf2), intersection));
                                });
                      });
            })
        .collect(ImmutableList.toImmutableList());
  }

  /** Return a list of flows exhibiting multipath inconsistencies in the network. */
  public Set<Flow> multipathInconsistencies(String flowTag) {
    return computeMultipathInconsistencies()
        .stream()
        .map(inconsistency -> multipathInconsistencyToFlow(inconsistency, flowTag))
        .collect(ImmutableSet.toImmutableSet());
  }

  Set<StateExpr> getLeafStates() {
    return _leafStates;
  }

  Map<StateExpr, Map<StateExpr, StateExpr>> getNatRoots() {
    _reachableStates.get(); // force the computation
    return _natRoots;
  }

  Map<StateExpr, Map<StateExpr, BDD>> getReachableStates() {
    return _reachableStates.get();
  }

  Map<StateExpr, Map<StateExpr, BDD>> getRootToLeafBDDs() {
    return _rootToLeafBDDs.get();
  }

  @VisibleForTesting
  Flow multipathInconsistencyToFlow(MultipathInconsistency violation, String flowTag) {
    Builder fb =
        _bddPacket
            .getFlow(violation.getBDD())
            .orElseGet(
                () -> {
                  throw new BatfishException("MultipathConsistencyViolation with UNSAT predicate");
                });
    StateExpr originateState = violation.getOriginateState();
    fb.setTag(flowTag);
    if (originateState instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) originateState;
      fb.setIngressNode(originateVrf.getHostname());
      fb.setIngressVrf(originateVrf.getVrf());
    } else if (originateState instanceof OriginateInterfaceLink) {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) originateState;
      fb.setIngressNode(originateInterfaceLink.getHostname());
      fb.setIngressInterface(originateInterfaceLink.getIface());
    } else {
      throw new BatfishException(
          "Unexpected originateState type: " + originateState.getClass().getSimpleName());
    }
    return fb.build();
  }
}
