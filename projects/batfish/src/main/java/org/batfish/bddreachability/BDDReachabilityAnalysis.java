package org.batfish.bddreachability;

import static com.google.common.base.Preconditions.checkNotNull;
import static org.batfish.common.util.CommonUtil.toImmutableMap;

import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Suppliers;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;
import com.google.common.collect.Multimap;
import com.google.common.collect.Sets;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Supplier;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.sf.javabdd.BDD;
import org.batfish.common.BatfishException;
import org.batfish.datamodel.Flow;
import org.batfish.datamodel.Flow.Builder;
import org.batfish.symbolic.bdd.BDDOps;
import org.batfish.symbolic.bdd.BDDPacket;
import org.batfish.z3.expr.StateExpr;
import org.batfish.z3.state.NumberedQuery;
import org.batfish.z3.state.OriginateInterfaceLink;
import org.batfish.z3.state.OriginateVrf;
import org.batfish.z3.state.visitors.DefaultTransitionGenerator;

/**
 * A new reachability analysis engine using BDDs. The analysis maintains a graph that describes how
 * packets flow through the network and through logical phases of a router. The graph is similar to
 * the one generated by {@link DefaultTransitionGenerator} for reachability analysis using NOD. In
 * particular, the graph nodes are {@link StateExpr StateExprs} and the edges are mostly the same as
 * the NOD program rules/transitions. {@link BDD BDDs} label the nodes and edges of the graph. A
 * node label represent the set of packets that can reach that node, and an edge label represents
 * the set of packets that can traverse the edge.
 *
 * <p>The two main departures from the NOD program are: 1) ACLs are encoded as a single BDD that
 * labels an edge (rather than a series of states/transitions in NOD programs). 2) Source NAT is
 * handled differently -- we don't maintain separate original and current source IP variables.
 * Instead, we keep track of where/how the packet is transformed as it flows through the network,
 * and reconstruct it after the fact. This requires some work that can't be expressed in BDDs.
 */
public class BDDReachabilityAnalysis {
  /*
   * Stores the essential information about a logical NAT root -- where the NAT occurred, and
   * what the original root was.
   */
  private static class NatRootPosition {
    final StateExpr _natPosition;
    final StateExpr _originalRoot;
    final List<BDDSourceNat> _sourceNats;

    NatRootPosition(StateExpr natPosition, StateExpr originalRoot, List<BDDSourceNat> sourceNats) {
      _natPosition = natPosition;
      _originalRoot = originalRoot;
      _sourceNats = sourceNats;
    }
  }

  private final BDDPacket _bddPacket;

  // preState --> postState --> predicate
  private final Map<StateExpr, Map<StateExpr, Edge>> _edges;

  private final Map<StateExpr, BDD> _graphRoots;

  // logical root --> (position,original root)
  private final Map<StateExpr, NatRootPosition> _natRootPositions;

  // natting postState --> root --> logical root
  private final Map<StateExpr, Map<StateExpr, StateExpr>> _natRoots;
  private int _natRootCounter = 0;

  // postState --> source state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _reachableStates;

  // root state --> leaf state --> predicate
  private final Supplier<Map<StateExpr, Map<StateExpr, BDD>>> _rootToLeafBDDs;

  // for NAT
  private final BDD _srcIpVars;

  private Set<StateExpr> _leafStates;

  BDDReachabilityAnalysis(
      Map<StateExpr, BDD> graphRoots, Map<StateExpr, Map<StateExpr, Edge>> transitions) {
    _bddPacket = new BDDPacket();
    _edges = transitions;
    _graphRoots = ImmutableMap.copyOf(graphRoots);
    _natRootPositions = new HashMap<>();
    _natRoots = new HashMap<>();
    _reachableStates = Suppliers.memoize(this::computeReachableStates);
    _rootToLeafBDDs = Suppliers.memoize(this::computeRootToLeafBDDs);
    _leafStates = computeTerminalStates();
    _srcIpVars = new BDDOps(BDDPacket.factory).and(_bddPacket.getSrcIp().getBitvec());
  }

  Map<StateExpr, Map<StateExpr, BDD>> getStatesReachableFromRoot(StateExpr root) {
    return _reachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> entry.getValue().containsKey(root))
        .collect(ImmutableMap.toImmutableMap(Entry::getKey, Entry::getValue));
  }

  /* backward-propagate nat roots to a fixed point */
  private void backwardPropagateNatRoots(Map<StateExpr, Map<StateExpr, BDD>> rootToLeafBDDs) {
    Set<StateExpr> natRootsWorkList = _natRootPositions.keySet();
    Map<StateExpr, Map<StateExpr, BDD>> reachableStates = _reachableStates.get();
    while (!natRootsWorkList.isEmpty()) {
      Set<StateExpr> newWorkList = new HashSet<>();
      for (StateExpr natRoot : natRootsWorkList) {
        NatRootPosition natRootPosition = _natRootPositions.get(natRoot);
        StateExpr originalRoot = natRootPosition._originalRoot;
        List<BDDSourceNat> sourceNats = natRootPosition._sourceNats;
        BDD reachNatBDD = reachableStates.get(natRootPosition._natPosition).get(originalRoot);
        Map<StateExpr, BDD> natRootLeafBDDs = rootToLeafBDDs.get(natRoot);

        if (natRootLeafBDDs == null) {
          Map<StateExpr, Map<StateExpr, BDD>> statesReachableFromRoot =
              getStatesReachableFromRoot(natRoot);
          break;
        }
        checkNotNull(natRootLeafBDDs, "natRoot %s missing rootToLeafBDDs entry", natRoot);

        natRootLeafBDDs.forEach(
            (leaf, bdd) -> {
              BDD bddExistSrcIp = bdd.exist(_srcIpVars);
              BDD preNatBDD = bdd.getFactory().zero();
              for (BDDSourceNat sourceNat : sourceNats) {
                if (!bdd.and(sourceNat._updateSrcIp).isZero()) {
                  // this could be the NAT rule that was applied
                  preNatBDD =
                      preNatBDD.or(reachNatBDD.and(sourceNat._condition).and(bddExistSrcIp));
                }
              }
              assert !preNatBDD.isZero();
              rootToLeafBDDs
                  .computeIfAbsent(originalRoot, k -> new HashMap<>())
                  .merge(leaf, preNatBDD, BDD::or);
              if (_natRootPositions.containsKey(originalRoot)) {
                // original root is also a nat root; keep back-propagating
                newWorkList.add(originalRoot);
              }
            });
      }
      natRootsWorkList = newWorkList;
    }
  }

  /*
   * node --> root --> set of headers that can reach node from root.
   */
  private Map<StateExpr, Map<StateExpr, BDD>> computeReachableStates() {
    Map<StateExpr, Map<StateExpr, BDD>> reachableStates = new HashMap<>();
    Multimap<StateExpr, StateExpr> dirty = HashMultimap.create();
    for (StateExpr root : _graphRoots.keySet()) {
      reachableStates.put(root, ImmutableMap.of(root, _graphRoots.get(root)));
      dirty.put(root, root);
    }

    List<Long> roundTimes = new LinkedList<>();
    List<Integer> roundDirties = new LinkedList<>();

    while (!dirty.isEmpty()) {
      Multimap<StateExpr, StateExpr> newDirty = HashMultimap.create();
      long time = System.currentTimeMillis();

      dirty.forEach(
          (preState, root) -> {
            Map<StateExpr, Edge> preStateOutEdges = _edges.get(preState);
            if (preStateOutEdges == null) {
              // preState has no out-edges
              return;
            }

            BDD preStateBDD = reachableStates.get(preState).get(root);
            preStateOutEdges.forEach(
                (postState, edge) -> {
                  BDD result = preStateBDD.and(edge.getConstraint());
                  if (result.isZero()) {
                    return;
                  }

                  // apply source nat
                  List<BDDSourceNat> sourceNats = edge.getSourceNats();
                  boolean natted = false;
                  if (sourceNats != null) {
                    BDD orig = result;
                    result = BDDPacket.factory.zero();
                    BDD reachLine = BDDPacket.factory.one();
                    for (BDDSourceNat sourceNat : Lists.reverse(sourceNats)) {
                      BDD matchLine = reachLine.and(sourceNat._condition);
                      result =
                          result.or(
                              orig.and(matchLine).exist(_srcIpVars).and(sourceNat._updateSrcIp));
                      reachLine = reachLine.and(sourceNat._condition.not());
                    }
                    result = result.or(orig.and(reachLine));
                    natted = !result.equals(orig);
                  }

                  /*
                   * We want to remember the original source IP, but NAT is destructive. So we
                   * introduce a new "root" state and map it to a new NatRootPosition, which
                   * has the information needed to recover the original source IP and original
                   * root.
                   */
                  StateExpr logicalRoot;
                  if (natted) {
                    logicalRoot =
                        _natRoots
                            .computeIfAbsent(postState, k -> new HashMap<>())
                            .computeIfAbsent(root, k -> new NumberedQuery(this._natRootCounter++));
                    _natRootPositions.computeIfAbsent(
                        logicalRoot, k -> new NatRootPosition(preState, root, sourceNats));
                  } else {
                    logicalRoot = root;
                  }

                  // update postState BDD reachable from root
                  Map<StateExpr, BDD> reachPostState =
                      reachableStates.computeIfAbsent(postState, k -> new HashMap<>());
                  BDD oldReach = reachPostState.get(logicalRoot);
                  BDD newReach = oldReach == null ? result : oldReach.or(result);

                  if (oldReach == null || !oldReach.equals(newReach)) {
                    reachPostState.put(logicalRoot, newReach);
                    newDirty.put(postState, logicalRoot);
                  }
                });
          });

      dirty = newDirty;

      time = System.currentTimeMillis() - time;
      roundTimes.add(time);
      roundDirties.add(dirty.size());
    }

    return toImmutableMap(
        reachableStates,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Map<StateExpr, Map<StateExpr, BDD>> computeRootToLeafBDDs() {
    // root --> leaf --> BDD
    Map<StateExpr, Map<StateExpr, BDD>> rootToLeafBDDs = new HashMap<>();
    _reachableStates
        .get()
        .entrySet()
        .stream()
        .filter(entry -> _leafStates.contains(entry.getKey()))
        .forEach(
            entry -> {
              StateExpr leafState = entry.getKey();
              entry
                  .getValue()
                  .forEach(
                      (root, bdd) -> {
                        rootToLeafBDDs
                            .computeIfAbsent(root, k -> new HashMap<>())
                            .put(leafState, bdd);
                      });
            });

    backwardPropagateNatRoots(rootToLeafBDDs);

    return toImmutableMap(
        rootToLeafBDDs,
        Entry::getKey,
        rootEntry -> toImmutableMap(rootEntry.getValue(), Entry::getKey, Entry::getValue));
  }

  private Set<StateExpr> computeTerminalStates() {
    Set<StateExpr> preStates = _edges.keySet();
    Set<StateExpr> postStates =
        _edges.values().stream().flatMap(m -> m.keySet().stream()).collect(Collectors.toSet());
    return ImmutableSet.copyOf(Sets.difference(postStates, preStates));
  }

  /**
   * Return a list of {@link MultipathInconsistency multipath consistency violations} detected in
   * the network.
   */
  @VisibleForTesting
  List<MultipathInconsistency> computeMultipathInconsistencies() {
    return _rootToLeafBDDs
        .get()
        .entrySet()
        .stream()
        .flatMap(
            entry -> {
              StateExpr root = entry.getKey();
              Map<StateExpr, BDD> leafBDDs = entry.getValue();
              return _leafStates
                  .stream()
                  .filter(leafBDDs::containsKey)
                  .flatMap(
                      leaf1 -> {
                        BDD leaf1BDD = leafBDDs.get(leaf1);
                        return _leafStates
                            .stream()
                            .filter(leaf2 -> leaf1 != leaf2)
                            .filter(leafBDDs::containsKey)
                            // avoid duplicate violations
                            .filter(leaf2 -> leaf1.toString().compareTo(leaf2.toString()) < 1)
                            .flatMap(
                                leaf2 -> {
                                  BDD leaf2BDD = leafBDDs.get(leaf2);
                                  BDD intersection = leaf1BDD.and(leaf2BDD);
                                  return intersection.isZero()
                                      ? Stream.empty()
                                      : Stream.of(
                                          new MultipathInconsistency(
                                              root, ImmutableSet.of(leaf1, leaf2), intersection));
                                });
                      });
            })
        .collect(ImmutableList.toImmutableList());
  }

  /** Return a list of flows exhibiting multipath inconsistencies in the network. */
  public Set<Flow> multipathInconsistencies(String flowTag) {
    return computeMultipathInconsistencies()
        .stream()
        .map(inconsistency -> multipathInconsistencyToFlow(inconsistency, flowTag))
        .collect(ImmutableSet.toImmutableSet());
  }

  Set<StateExpr> getLeafStates() {
    return _leafStates;
  }

  Map<StateExpr, Map<StateExpr, StateExpr>> getNatRoots() {
    _reachableStates.get(); // force the computation
    return _natRoots;
  }

  Map<StateExpr, Map<StateExpr, BDD>> getReachableStates() {
    return _reachableStates.get();
  }

  Map<StateExpr, Map<StateExpr, BDD>> getRootToLeafBDDs() {
    return _rootToLeafBDDs.get();
  }

  @VisibleForTesting
  Flow multipathInconsistencyToFlow(MultipathInconsistency violation, String flowTag) {
    Builder fb =
        _bddPacket
            .getFlow(violation.getBDD())
            .orElseGet(
                () -> {
                  throw new BatfishException("MultipathConsistencyViolation with UNSAT predicate");
                });
    StateExpr originateState = violation.getOriginateState();
    fb.setTag(flowTag);
    if (originateState instanceof OriginateVrf) {
      OriginateVrf originateVrf = (OriginateVrf) originateState;
      fb.setIngressNode(originateVrf.getHostname());
      fb.setIngressVrf(originateVrf.getVrf());
    } else if (originateState instanceof OriginateInterfaceLink) {
      OriginateInterfaceLink originateInterfaceLink = (OriginateInterfaceLink) originateState;
      fb.setIngressNode(originateInterfaceLink.getHostname());
      fb.setIngressInterface(originateInterfaceLink.getIface());
    } else {
      throw new BatfishException(
          "Unexpected originateState type: " + originateState.getClass().getSimpleName());
    }
    return fb.build();
  }
}
